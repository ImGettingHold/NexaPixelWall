export const version: string;
export function versionGuard(version: any): void;
export namespace crypto {
    let BN: typeof import("bn.js");
    let ECDSA: typeof import("./lib/crypto/ecdsa");
    let Schnorr: typeof import("./lib/crypto/schnorr");
    let Hash: typeof import("./lib/crypto/hash");
    let Random: typeof import("./lib/crypto/random");
    let Point: typeof import("./lib/crypto/point");
    let Signature: typeof import("./lib/crypto/signature");
}
export namespace encoding {
    let Base58: typeof import("./lib/encoding/base58");
    let Base58Check: typeof import("./lib/encoding/base58check");
    let BufferReader: typeof import("./lib/encoding/bufferreader");
    let BufferWriter: typeof import("./lib/encoding/bufferwriter");
    let Varint: typeof import("./lib/encoding/varint");
}
export namespace util {
    let buffer: {
        fill: (buffer: Buffer, value: number) => Buffer;
        copy: (original: Buffer) => Buffer;
        isBuffer: (arg: any) => boolean;
        emptyBuffer: (bytes: number) => Buffer;
        concat: (list: readonly Uint8Array[], totalLength?: number) => Buffer;
        equals: (a: any, b: any) => boolean;
        equal: (a: any, b: any) => boolean;
        integerAsSingleByteBuffer: (integer: number) => Buffer;
        integerAsBuffer: (integer: number) => Buffer;
        integerFromBuffer: (buffer: Buffer) => number;
        integerFromSingleByteBuffer: (buffer: Buffer) => number;
        bufferToHex: (buffer: Buffer) => string;
        reverse: (param: Buffer) => Buffer;
        NULL_HASH: Buffer;
        EMPTY_BUFFER: Buffer;
    };
    let js: {
        isValidJSON: (arg: string) => any;
        isHexa: (value: string) => boolean;
        isHexaString: (value: string) => boolean;
        cloneArray: (array: any) => any[];
        defineImmutable: (target: any, values: any) => any;
        isNaturalNumber: (value: any) => boolean;
    };
    let preconditions: {
        checkState: (condition: any, message: any) => void;
        checkArgument: (condition: any, argumentName: any, message: any, docsPath: any) => void;
        checkArgumentType: (argument: any, type: any, argumentName: any) => void;
    };
    let base32: {
        encode: (data: any[]) => string;
        decode: (base32: string) => any[];
    };
    let convertBits: (data: any, from: any, to: any, strict: any) => number[];
}
export const errors: Error;
export const Address: typeof import("./lib/address");
export const GroupToken: typeof import("./lib/grouptoken");
export const Block: {
    (arg: any): import("./lib/block/block");
    new (arg: any): import("./lib/block/block");
    MAX_BLOCK_SIZE: number;
    _from(arg: any): any;
    _fromObject(data: any): any;
    fromObject(obj: any): import("./lib/block/block");
    _fromBufferReader(br: import("./lib/encoding/bufferreader")): any;
    fromBufferReader(br: import("./lib/encoding/bufferreader")): import("./lib/block/block");
    fromBuffer(buf: Buffer): import("./lib/block/block");
    fromString(str: string): import("./lib/block/block");
    fromRawBlock(data: BinaryData | Buffer): import("./lib/block/block");
    Values: {
        START_OF_BLOCK: number;
        NULL_HASH: Buffer;
    };
    BlockHeader: typeof import("./lib/block/blockheader");
    MerkleBlock: typeof import("./lib/block/merkleblock");
};
export const MerkleBlock: typeof import("./lib/block/merkleblock");
export const BlockHeader: typeof import("./lib/block/blockheader");
export const HDPrivateKey: typeof import("./lib/hdprivatekey.js");
export const HDPublicKey: typeof import("./lib/hdpublickey.js");
export const Message: typeof import("./lib/message");
export const Networks: {
    add: (data: {
        name: string;
        alias: string;
        pubkeyhash: number;
        privatekey: number;
        scripthash: number;
        xpubkey: number;
        xprivkey: number;
        networkMagic: number;
        port: number;
        dnsSeeds: any[];
    }) => import("./lib/networks").Network;
    remove: (network: import("./lib/networks").Network) => void;
    defaultNetwork: any;
    livenet: any;
    mainnet: any;
    testnet: any;
    regtest: any;
    get: (arg: string | number | import("./lib/networks").Network, keys: string | any[]) => any;
    enableRegtest: () => void;
    disableRegtest: () => void;
    Network: typeof import("./lib/networks").Network;
};
export const Opcode: typeof import("./lib/opcode");
export const PrivateKey: typeof import("./lib/privatekey");
export const PublicKey: typeof import("./lib/publickey");
export const Script: typeof import("./lib/script/script");
export const ScriptInterpreter: typeof import("./lib/script/interpreter");
export const Transaction: {
    (serialized?: any): import("./lib/transaction/transaction");
    new (serialized?: any): import("./lib/transaction/transaction");
    DUST_AMOUNT: number;
    FEE_SECURITY_MARGIN: number;
    MAX_MONEY: number;
    NLOCKTIME_BLOCKHEIGHT_LIMIT: number;
    NLOCKTIME_MAX_VALUE: number;
    FEE_PER_KB: number;
    CHANGE_OUTPUT_MAX_SIZE: number;
    shallowCopy(transaction: import("./lib/transaction/transaction")): import("./lib/transaction/transaction");
    Input: {
        (params: any): import("./lib/transaction/input/input");
        new (params: any): import("./lib/transaction/input/input");
        MAXINT: number;
        DEFAULT_SEQNUMBER: number;
        DEFAULT_LOCKTIME_SEQNUMBER: number;
        DEFAULT_RBF_SEQNUMBER: number;
        SEQUENCE_LOCKTIME_TYPE_FLAG: number;
        DEFAULT_TYPE: number;
        fromObject(obj: any): import("./lib/transaction/input/input");
        fromBufferReader(br: any): import("./lib/transaction/input/input");
        PublicKey: typeof import("./lib/transaction/input/publickey");
        PublicKeyHash: typeof import("./lib/transaction/input/publickeyhash");
        PublicKeyTemplate: typeof import("./lib/transaction/input/publickeytemplate");
        MultiSig: typeof import("./lib/transaction/input/multisig");
        MultiSigScriptHash: typeof import("./lib/transaction/input/multisigscripthash");
        Escrow: typeof import("./lib/transaction/input/escrow");
        ScriptTemplate: typeof import("./lib/transaction/input/scripttemplate");
    };
    Output: typeof import("./lib/transaction/output");
    UnspentOutput: typeof import("./lib/transaction/unspentoutput");
    Signature: typeof import("./lib/transaction/signature");
    Sighash: {
        sighash: (transaction: import("./lib/transaction/transaction"), sighashType: number, inputNumber: number, subscript: {
            (from?: any): import("./lib/script/script");
            new (from?: any): import("./lib/script/script");
            fromBuffer(buffer: any): import("./lib/script/script");
            fromASM(str: any): import("./lib/script/script");
            fromHex(str: any): import("./lib/script/script");
            fromString(str: any): import("./lib/script/script");
            types: typeof import("./lib/script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("./lib/script/script").outputIdentifiers;
            inputIdentifiers: typeof import("./lib/script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("./lib/publickey")[], reclaimPublicKey: import("./lib/publickey")): import("./lib/script/script");
            buildMultisigOut(publicKeys: import("./lib/publickey")[], threshold: number, opts?: any): import("./lib/script/script");
            buildMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildP2SHMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildPublicKeyHashOut(to: import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildGroupedScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildPublicKeyOut(pubkey: any): import("./lib/script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("./lib/script/script");
            buildScriptHashOut(script: import("./lib/address") | import("./lib/script/script")): import("./lib/script/script");
            buildPublicKeyIn(signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildScriptTemplateIn(template: import("./lib/script/script"), constraint: import("./lib/opcode") | import("./lib/script/script"), satisfier: Buffer | import("./lib/script/script"), sigtype?: number): import("./lib/script/script");
            buildEscrowIn(publicKey: import("./lib/publickey"), signature: import("./lib/crypto/signature"), redeemScript: import("./lib/script/script")): import("./lib/script/script");
            empty(): import("./lib/script/script");
            fromAddress(address: any): import("./lib/script/script");
            Interpreter: typeof import("./lib/script/interpreter");
        }, satoshisBN: any, flags: any) => Buffer;
        sign: (transaction: Transaction, privateKey: PrivateKey, sighashType: any, inputIndex: number, subscript: {
            (from?: any): import("./lib/script/script");
            new (from?: any): import("./lib/script/script");
            fromBuffer(buffer: any): import("./lib/script/script");
            fromASM(str: any): import("./lib/script/script");
            fromHex(str: any): import("./lib/script/script");
            fromString(str: any): import("./lib/script/script");
            types: typeof import("./lib/script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("./lib/script/script").outputIdentifiers;
            inputIdentifiers: typeof import("./lib/script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("./lib/publickey")[], reclaimPublicKey: import("./lib/publickey")): import("./lib/script/script");
            buildMultisigOut(publicKeys: import("./lib/publickey")[], threshold: number, opts?: any): import("./lib/script/script");
            buildMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildP2SHMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildPublicKeyHashOut(to: import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildGroupedScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildPublicKeyOut(pubkey: any): import("./lib/script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("./lib/script/script");
            buildScriptHashOut(script: import("./lib/address") | import("./lib/script/script")): import("./lib/script/script");
            buildPublicKeyIn(signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildScriptTemplateIn(template: import("./lib/script/script"), constraint: import("./lib/opcode") | import("./lib/script/script"), satisfier: Buffer | import("./lib/script/script"), sigtype?: number): import("./lib/script/script");
            buildEscrowIn(publicKey: import("./lib/publickey"), signature: import("./lib/crypto/signature"), redeemScript: import("./lib/script/script")): import("./lib/script/script");
            empty(): import("./lib/script/script");
            fromAddress(address: any): import("./lib/script/script");
            Interpreter: typeof import("./lib/script/interpreter");
        }, satoshisBN: any, flags: any, signingMethod: any) => import("./lib/crypto/signature");
        verify: (transaction: Transaction, signature: import("./lib/crypto/signature"), publicKey: PublicKey, inputIndex: number, subscript: {
            (from?: any): import("./lib/script/script");
            new (from?: any): import("./lib/script/script");
            fromBuffer(buffer: any): import("./lib/script/script");
            fromASM(str: any): import("./lib/script/script");
            fromHex(str: any): import("./lib/script/script");
            fromString(str: any): import("./lib/script/script");
            types: typeof import("./lib/script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("./lib/script/script").outputIdentifiers;
            inputIdentifiers: typeof import("./lib/script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("./lib/publickey")[], reclaimPublicKey: import("./lib/publickey")): import("./lib/script/script");
            buildMultisigOut(publicKeys: import("./lib/publickey")[], threshold: number, opts?: any): import("./lib/script/script");
            buildMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildP2SHMultisigIn(pubkeys: import("./lib/publickey")[], threshold: number, signatures: any[], opts?: any): import("./lib/script/script");
            buildPublicKeyHashOut(to: import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address")): import("./lib/script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildGroupedScriptTemplateOut(to: string | import("./lib/publickey") | import("./lib/address"), groupId: string | Buffer | import("./lib/address"), groupAmount: bigint | Buffer): import("./lib/script/script");
            buildPublicKeyOut(pubkey: any): import("./lib/script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("./lib/script/script");
            buildScriptHashOut(script: import("./lib/address") | import("./lib/script/script")): import("./lib/script/script");
            buildPublicKeyIn(signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("./lib/publickey"), signature: Buffer | import("./lib/crypto/signature"), sigtype?: number): import("./lib/script/script");
            buildScriptTemplateIn(template: import("./lib/script/script"), constraint: import("./lib/opcode") | import("./lib/script/script"), satisfier: Buffer | import("./lib/script/script"), sigtype?: number): import("./lib/script/script");
            buildEscrowIn(publicKey: import("./lib/publickey"), signature: import("./lib/crypto/signature"), redeemScript: import("./lib/script/script")): import("./lib/script/script");
            empty(): import("./lib/script/script");
            fromAddress(address: any): import("./lib/script/script");
            Interpreter: typeof import("./lib/script/interpreter");
        }, satoshisBN: any, flags: any, signingMethod: any) => boolean;
    };
};
export const URI: typeof import("./lib/uri");
export const Unit: typeof import("./lib/unit");
export namespace deps {
    export let bnjs: typeof import("bn.js");
    export let bs58: any;
    let Buffer_1: BufferConstructor;
    export { Buffer_1 as Buffer };
    export let elliptic: any;
    export let _: _.LoDashStatic;
}
//# sourceMappingURL=index.d.ts.map