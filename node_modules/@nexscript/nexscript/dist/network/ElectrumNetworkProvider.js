import { ElectrumCluster, ElectrumTransport, ClusterOrder, } from '@vgrunner/electrum-cash';
import { Network } from '../interfaces.js';
export default class ElectrumNetworkProvider {
    constructor(network = globalThis.process?.env?.JEST_WORKER_ID === undefined ? Network.MAINNET : Network.REGTEST, electrum, manualConnectionManagement) {
        this.network = network;
        this.manualConnectionManagement = manualConnectionManagement;
        this.concurrentRequests = 0;
        // If a custom Electrum Cluster is passed, we use it instead of the default.
        if (electrum) {
            this.electrum = electrum;
            return;
        }
        if (network === Network.MAINNET) {
            this.electrum = new ElectrumCluster('NexScript Application', '1.4.1', 1, 1, ClusterOrder.PRIORITY, undefined, undefined, true);
            this.electrum.addServer('electrum.nexa.org', 20004, ElectrumTransport.WSS.Scheme, false);
        }
        else if (network === Network.TESTNET) {
            this.electrum = new ElectrumCluster('NexScript Application', '1.4.1', 1, 1, ClusterOrder.PRIORITY, undefined, undefined, true);
            this.electrum.addServer('testnet-explorer.nexa.org', 30004, ElectrumTransport.WSS.Scheme, false);
        }
        else if (network === Network.REGTEST) {
            this.electrum = new ElectrumCluster('NexScript Application', '1.4.1', 1, 1, ClusterOrder.PRIORITY, undefined, undefined, true);
            this.electrum.addServer('127.0.0.1', 30403, ElectrumTransport.WS.Scheme, false);
        }
        else {
            throw new Error(`Tried to instantiate an ElectrumNetworkProvider for unsupported network ${network}`);
        }
    }
    async getUtxos(address) {
        const [allUtxos, tokenUtxos] = await Promise.all([
            this.performRequest('blockchain.address.listunspent', address),
            this.performRequest('token.address.listunspent', address),
        ]);
        const completeUtxos = allUtxos.map((val) => {
            const tokenUtxo = tokenUtxos.unspent.find((utxo) => utxo.tx_hash === val.tx_hash
                && utxo.tx_pos === val.tx_pos);
            return { ...val, ...tokenUtxo };
        });
        const utxos = completeUtxos.map((utxo) => ({
            // txid: utxo.tx_hash,
            txid: utxo.outpoint_hash,
            vout: utxo.tx_pos,
            satoshis: BigInt(utxo.value),
            address,
            token: utxo.group ? {
                groupId: utxo.token_id_hex,
                amount: BigInt(utxo.token_amount),
            } : undefined,
        }));
        return utxos;
    }
    async getBlockHeight() {
        const { height } = await this.performRequest('blockchain.headers.subscribe');
        return height;
    }
    async getRawTransaction(txid) {
        return await this.performRequest('blockchain.transaction.get', txid);
    }
    async sendRawTransaction(txHex) {
        return await this.performRequest('blockchain.transaction.broadcast', txHex);
    }
    async connectCluster() {
        try {
            return await this.electrum.startup();
        }
        catch (e) {
            return [];
        }
    }
    async disconnectCluster() {
        return this.electrum.shutdown();
    }
    async performRequest(name, ...parameters) {
        // Only connect the cluster when no concurrent requests are running
        if (this.shouldConnect()) {
            this.connectCluster();
        }
        this.concurrentRequests += 1;
        await this.electrum.ready();
        let result;
        try {
            result = await this.electrum.request(name, ...parameters);
        }
        finally {
            // Always disconnect the cluster, also if the request fails
            // as long as no other concurrent requests are running
            if (this.shouldDisconnect()) {
                await this.disconnectCluster();
            }
        }
        this.concurrentRequests -= 1;
        if (result instanceof Error)
            throw result;
        return result;
    }
    shouldConnect() {
        if (this.manualConnectionManagement)
            return false;
        if (this.concurrentRequests !== 0)
            return false;
        return true;
    }
    shouldDisconnect() {
        if (this.manualConnectionManagement)
            return false;
        if (this.concurrentRequests !== 1)
            return false;
        return true;
    }
}
//# sourceMappingURL=ElectrumNetworkProvider.js.map