import { binToHex, decodePrivateKeyWif, secp256k1, SigningSerializationFlag, } from '@bitauth/libauth';
import nexcore from 'nexcore-lib';
import { HashType, SignatureAlgorithm } from './interfaces.js';
export default class SignatureTemplate {
    constructor(signer, hashtype = HashType.SIGHASH_ALL, signatureAlgorithm = SignatureAlgorithm.SCHNORR) {
        this.hashtype = hashtype;
        this.signatureAlgorithm = signatureAlgorithm;
        if (isKeypair(signer)) {
            const wif = signer.toWIF();
            this.privateKey = decodeWif(wif);
        }
        else if (typeof signer === 'string') {
            this.privateKey = decodeWif(signer);
        }
        else {
            this.privateKey = signer;
        }
    }
    generateSignature(payload, bchForkId) {
        const signature = this.signatureAlgorithm === SignatureAlgorithm.SCHNORR
            ? secp256k1.signMessageHashSchnorr(this.privateKey, payload)
            : secp256k1.signMessageHashDER(this.privateKey, payload);
        return Uint8Array.from([...signature, this.getHashType(bchForkId)]);
    }
    getHashType(bchForkId = true) {
        return bchForkId ? (this.hashtype | SigningSerializationFlag.forkId) : this.hashtype;
    }
    getPublicKey() {
        return secp256k1.derivePublicKeyCompressed(this.privateKey);
    }
    unlockP2PKT() {
        const signatureTemplate = this;
        return {
            addInput({ transaction, input }) {
                const txo = {
                    txId: input.txid,
                    outputIndex: input.vout,
                    satoshis: Number(input.satoshis),
                    address: input.address,
                };
                transaction.from(txo);
            },
            signInput({ transaction, inputIndex: index, network, }) {
                const nexPrivateKey = nexcore.PrivateKey(binToHex(signatureTemplate.privateKey), network);
                const signatures = transaction.inputs[index].getSignatures(transaction, nexPrivateKey, index, nexcore.crypto.Signature.SIGHASH_NEXA_ALL);
                transaction.inputs[index].addSignature(transaction, signatures[0], 'schnorr');
            },
        };
    }
}
function isKeypair(obj) {
    return typeof obj.toWIF === 'function';
}
function decodeWif(wif) {
    const result = decodePrivateKeyWif(wif);
    if (typeof result === 'string') {
        throw new Error(result);
    }
    return result.privateKey;
}
//# sourceMappingURL=SignatureTemplate.js.map