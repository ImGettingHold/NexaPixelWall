import { binToHex, hash160, utf8ToBin } from '@bitauth/libauth';
import { MerkleTree } from 'merkletreejs';
/*
 * Get nearest rounded down log2 base using only bitwise operations
 */
export const ulog2 = (u) => {
    let s;
    let t;
    // eslint-disable-next-line
    t = Number(u > 0xffff) << 4;
    u >>= t;
    // eslint-disable-next-line
    s = Number(u > 0xff) << 3;
    u >>= s, t |= s;
    // eslint-disable-next-line
    s = Number(u > 0xf) << 2;
    u >>= s, t |= s;
    // eslint-disable-next-line
    s = Number(u > 0x3) << 1;
    u >>= s, t |= s;
    return (t | (u >> 1));
};
/*
 * Transform a full proof of last element in the data set into a compact proof
 */
export const ToCompactProof = (fullProof, elementIndex) => {
    let index = 0;
    while (elementIndex) {
        if (elementIndex & 1) {
            index += 1;
        }
        else {
            fullProof.splice(index, 1);
        }
        elementIndex >>= 1;
    }
    return fullProof;
};
/*
 * Transform the compact proof of last element in the data set into a full proof.
 * This involves computation of the hashes of duplicated (right hand sided) merkle tree elements
 *   to fill the gaps in the sparse compact proof
 * Optionally this method also returns the root of the merkle tree in question
 */
export const ToFullProof = (leafHash, compactProof, elementIndex) => {
    let hash = leafHash; // previous element hash
    let index = 0;
    const result = [];
    let size = 0;
    while (elementIndex) {
        if (elementIndex & 1) {
            // simply copy from merkle branch and compute this level's hash
            result.push(compactProof[index]);
            hash = hash160(Uint8Array.from([...compactProof[index], ...hash]));
            index += 1;
        }
        else {
            if (!size) {
                // first element being leaf hash
                result.push(leafHash);
            }
            else {
                result.push(hash);
            }
            // compute missing hash from duplicated items
            hash = hash160(Uint8Array.from([...hash, ...hash]));
        }
        size += 1;
        elementIndex >>= 1;
    }
    return { fullProof: result, root: hash };
};
/*
 * Get the new compact proof given the old compact proof info - sparse proof, previous element hash and previous element index
 *
 * This method is the key for a zero-knowledge expansion of a data set given its previous state.
 * Contracts can use it to permissionlessly and trustlessly propose the next state of a decentralized dataset.
 */
export const GetNewCompactProof = (prevLeafHash, prevCompactProof, prevIndex) => {
    const newIndex = prevIndex + 1; // aka binaryPath
    let setBits = ((newIndex - 1) ^ (newIndex)) & (newIndex);
    let newCompactProof = [];
    if (setBits === 1) {
        newCompactProof = [prevLeafHash, ...prevCompactProof];
    }
    else if (setBits === (1 << ulog2(prevIndex))) {
        newCompactProof = [ComputeMerkleRootFromBranch(prevLeafHash, prevCompactProof, 0xffffffff)];
    }
    else {
        let level = 0;
        while ((setBits & 1) === 0) {
            level += 1;
            setBits >>= 1;
        }
        const lowPart = prevCompactProof.slice(0, level);
        const highPart = prevCompactProof.slice(level);
        const subRoot = ComputeMerkleRootFromBranch(prevLeafHash, lowPart, 0xffffffff);
        newCompactProof = [subRoot, ...highPart];
    }
    return newCompactProof;
};
/* To verify a merkle proof, pass the hash of the element in "leaf", the merkle proof in "branch", and the zero-based
index specifying where the element was in the array when the merkle proof was created.
*/
export const ComputeMerkleRootFromBranch = (leaf, merkleBranch, nIndex) => {
    let hash = leaf;
    for (const element of merkleBranch) {
        if (nIndex & 1) {
            hash = hash160(Uint8Array.from([...element, ...hash]));
        }
        else {
            hash = hash160(Uint8Array.from([...hash, ...element]));
        }
        nIndex >>= 1;
    }
    return hash;
};
export function SerializeProof(proof) {
    if (!proof.length) {
        throw Error('Empty proof');
    }
    if (proof[0].data) {
        return proof.slice().reverse().map((element) => `14${binToHex(element.data)}`).join('');
    }
    return proof.slice().reverse().map((element) => `14${binToHex(element)}`).join('');
}
export const MerkleHash160 = (value) => Buffer.from(hash160(typeof value === 'string' ? utf8ToBin(value) : value));
/*
 * Utility function to get merkle root and serialized proof from a list of hashes and leaf index, used with `merkleRoot` macro
 */
export const GetMerkleParams = (hashes, leafIndex, hash = MerkleHash160) => {
    const tree = new MerkleTree(hashes, hash, {
        hashLeaves: false,
        duplicateOdd: true,
    });
    let proof = tree.getProof(hashes[leafIndex]);
    if (proof.length < ulog2(hashes.length - 1) + 1) {
        const index = leafIndex;
        const { fullProof } = ToFullProof(Uint8Array.from([...hashes[leafIndex]]), proof.map((val) => Uint8Array.from([...val.data])), index);
        const positioned = fullProof.map((fullProofElement) => ({
            position: proof.find((val) => val.data.equals(Buffer.from(fullProofElement)))?.position ?? 'left',
            data: Buffer.from(fullProofElement),
        }));
        proof = positioned;
    }
    const root = tree.getRoot().toString('hex');
    const serializedProof = SerializeProof(proof);
    return {
        root,
        serializedProof,
    };
};
//# sourceMappingURL=merkle.js.map