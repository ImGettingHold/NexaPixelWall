import { CircularDependencyError } from '../Errors.js';
import AstTraversal from '../ast/AstTraversal.js';
export default class DependencyTraversal extends AstTraversal {
    constructor() {
        super(...arguments);
        this.dependencyMap = {};
    }
    visitContract(node) {
        this.currentContract = node.name;
        this.dependencyMap[this.currentContract] = [];
        node.contracts.forEach((contract) => this.visitContract(contract));
        return super.visitContract(node);
    }
    visitContractAccessor(node) {
        if (this.dependencyMap[this.currentContract].indexOf(node.contract.name) === -1) {
            this.dependencyMap[this.currentContract].push(node.contract.name);
        }
        return super.visitContractAccessor(node);
    }
    buildDependencyList(contract, dependencies) {
        const nodes = {};
        let nodeCount = 0;
        const ready = [];
        const output = [];
        const add = (element) => {
            nodeCount += 1;
            nodes[element] = { needs: [], neededBy: [], name: element };
            if (dependencies[element]) {
                dependencies[element].forEach((dependency) => {
                    if (!nodes[dependency]) {
                        add(dependency);
                    }
                    nodes[element].needs.push(nodes[dependency]);
                    nodes[dependency].neededBy.push(nodes[element]);
                });
            }
            if (!nodes[element].needs.length) {
                ready.push(nodes[element]);
            }
        };
        if (contract) {
            add(contract);
        }
        else {
            for (const element in dependencies) {
                if (!nodes[element]) {
                    add(element);
                }
            }
        }
        // sort
        while (ready.length) {
            const dependency = ready.pop();
            output.push(dependency.name);
            dependency.neededBy.forEach((element) => {
                element.needs = element.needs.filter((x) => x !== dependency);
                if (!element.needs.length) {
                    ready.push(element);
                }
            });
        }
        if (output.length !== nodeCount) {
            throw new CircularDependencyError(contract);
        }
        return output.slice(0, -1);
    }
}
//# sourceMappingURL=DependencyTraversal.js.map