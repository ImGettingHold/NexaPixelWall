import { hexToBin } from '@bitauth/libauth';
import { asmToScript, BytesType, encodeBool, encodeInt, encodeString, Op, PrimitiveType, resultingType, scriptToAsm, } from '@nexscript/utils';
import { HexLiteralNode, } from '../ast/AST.js';
import AstTraversal from '../ast/AstTraversal.js';
import { GlobalFunction, Class, PushTxStateSpecifierMap } from '../ast/Globals.js';
import { BinaryOperator } from '../ast/Operator.js';
import { compileBinaryOp, compileCast, compileGlobalFunction, compileNullaryOp, compileTimeOp, compileUnaryOp, } from './utils.js';
import { InvalidParameterTypeError } from '../Errors.js';
const GroupGlobalFunctions = [GlobalFunction.GROUP_AMOUNT_IN, GlobalFunction.GROUP_AMOUNT_OUT,
    GlobalFunction.GROUP_COUNT_IN, GlobalFunction.GROUP_COUNT_OUT, GlobalFunction.GROUP_NTH_INPUT,
    GlobalFunction.GROUP_NTH_OUTPUT];
const GroupNthFunctions = [GlobalFunction.GROUP_NTH_INPUT, GlobalFunction.GROUP_NTH_OUTPUT];
export default class GenerateTargetTraversal extends AstTraversal {
    constructor() {
        super(...arguments);
        this.output = [];
        this.stack = [];
        this.scopeDepth = 0;
    }
    emit(op) {
        if (Array.isArray(op)) {
            this.output.push(...op);
        }
        else {
            this.output.push(op);
        }
    }
    pushToStack(value, pushToBottom) {
        if (pushToBottom) {
            this.stack.push(value);
        }
        else {
            this.stack.unshift(value);
        }
    }
    popFromStack(count = 1) {
        for (let i = 0; i < count; i += 1) {
            this.stack.shift();
        }
    }
    removeFromStack(i) {
        this.stack.splice(i, 1);
    }
    nipFromStack() {
        this.stack.splice(1, 1);
    }
    getStackIndex(value) {
        const index = this.stack.indexOf(value);
        if (index === -1)
            throw new Error(); // Should not happen
        return index;
    }
    visitSourceFile(node) {
        node.contracts = this.visitList(node.contracts);
        // Minimally encode output by going Script -> ASM -> Script
        this.output = asmToScript(scriptToAsm(this.output));
        return node;
    }
    visitContract(node) {
        node.parameters = this.visitList(node.parameters);
        node.parameters.slice().reverse().forEach((parameter) => {
            this.emit(Op.OP_FROMALTSTACK);
            if (parameter.unused) {
                this.emit(Op.OP_DROP);
                this.removeFromStack(this.getStackIndex(parameter.name));
            }
        });
        if (node.functions.length === 1) {
            node.functions = this.visitList(node.functions);
        }
        else {
            this.pushToStack('$$', true);
            node.functions = node.functions.map((f, i) => {
                const stackCopy = [...this.stack];
                const selectorIndex = this.getStackIndex('$$');
                this.emit(encodeInt(BigInt(selectorIndex)));
                if (i === node.functions.length - 1) {
                    this.emit(Op.OP_ROLL);
                    this.removeFromStack(selectorIndex);
                }
                else {
                    this.emit(Op.OP_PICK);
                }
                // All functions are if-else statements, except the final one which is
                // enforced with NUMEQUALVERIFY
                this.emit(encodeInt(BigInt(i)));
                this.emit(Op.OP_NUMEQUAL);
                if (i < node.functions.length - 1) {
                    this.emit(Op.OP_IF);
                }
                else {
                    this.emit(Op.OP_VERIFY);
                }
                f = this.visit(f);
                if (i < node.functions.length - 1) {
                    this.emit(Op.OP_ELSE);
                }
                this.stack = [...stackCopy];
                return f;
            });
            for (let i = 0; i < node.functions.length - 1; i += 1) {
                this.emit(Op.OP_ENDIF);
            }
        }
        return node;
    }
    visitContractAccessor(node) {
        // simply emit
        // this.emit(utf8ToBin(`${node.contract}${node.accessor}`));
        this.emit(`${node.contract}${node.accessor}`);
        return node;
    }
    visitFunctionDefinition(node) {
        this.currentFunction = node;
        node.parameters = this.visitList(node.parameters);
        node.body = this.visit(node.body);
        // this.removeFinalVerify();
        this.cleanStack();
        return node;
    }
    removeFinalVerify() {
        // After EnsureFinalRequireTraversal, we know that the final opcodes are either
        // "OP_VERIFY", "OP_CHECK{LOCKTIME|SEQUENCE}VERIFY OP_DROP" or "OP_ENDIF"
        const finalOp = this.output.pop();
        // If the final op is OP_VERIFY and the stack size is less than 4 we remove it from the script
        // - We have the stack size check because it is more efficient to use 2DROP rather than NIP
        //   if >= 4 elements are left (5 including final value) (e.g. 2DROP 2DROP 1 < NIP NIP NIP NIP)
        if (finalOp === Op.OP_VERIFY && this.stack.length < 4) {
            // Since the final value is no longer popped from the stack by OP_VERIFY,
            // we add it back to the stack
            this.pushToStack('(value)');
        }
        else {
            this.emit(finalOp);
            // At this point there is no verification value left on the stack:
            //  - scoped stack is cleared inside branch ended by OP_ENDIF
            //  - OP_CHECK{LOCKTIME|SEQUENCE}VERIFY OP_DROP does not leave a verification value
            // so we add OP_1 to the script (indicating success)
            this.emit(Op.OP_1);
            this.pushToStack('(value)');
        }
    }
    cleanStack() {
        // OP_DROP all remaining stack items
        const stackSize = this.stack.length;
        for (let i = 0; i < stackSize; i += 1) {
            this.emit(Op.OP_DROP);
            this.popFromStack();
        }
    }
    visitParameter(node) {
        this.pushToStack(node.name, true);
        return node;
    }
    visitVariableDefinition(node) {
        node.expression = this.visit(node.expression);
        this.popFromStack();
        this.pushToStack(node.name);
        return node;
    }
    visitTupleAssignment(node) {
        node.tuple = this.visit(node.tuple);
        this.popFromStack(2);
        this.pushToStack(node.var1.name);
        this.pushToStack(node.var2.name);
        return node;
    }
    visitAssign(node) {
        node.expression = this.visit(node.expression);
        if (this.scopeDepth > 0) {
            this.emitReplace(this.getStackIndex(node.identifier.name));
            this.popFromStack();
        }
        else {
            this.popFromStack();
            this.pushToStack(node.identifier.name);
        }
        return node;
    }
    // This algorithm can be optimised for hardcoded depths
    // See thesis for explanation
    emitReplace(index) {
        this.emit(encodeInt(BigInt(index)));
        this.emit(Op.OP_ROLL);
        this.emit(Op.OP_DROP);
        for (let i = 0; i < index - 1; i += 1) {
            this.emit(Op.OP_SWAP);
            if (i < index - 2) {
                this.emit(Op.OP_TOALTSTACK);
            }
        }
        for (let i = 0; i < index - 2; i += 1) {
            this.emit(Op.OP_FROMALTSTACK);
        }
    }
    visitTimeOp(node) {
        node.expression = this.visit(node.expression);
        this.emit(compileTimeOp(node.timeOp));
        this.popFromStack();
        return node;
    }
    visitRequire(node) {
        node.expression = this.visit(node.expression);
        this.emit(Op.OP_VERIFY);
        this.popFromStack();
        return node;
    }
    visitBranch(node) {
        node.condition = this.visit(node.condition);
        this.popFromStack();
        this.scopeDepth += 1;
        this.emit(Op.OP_IF);
        let stackDepth = this.stack.length;
        node.ifBlock = this.visit(node.ifBlock);
        this.removeScopedVariables(stackDepth);
        if (node.elseBlock) {
            this.emit(Op.OP_ELSE);
            stackDepth = this.stack.length;
            node.elseBlock = this.visit(node.elseBlock);
            this.removeScopedVariables(stackDepth);
        }
        this.emit(Op.OP_ENDIF);
        this.scopeDepth -= 1;
        return node;
    }
    removeScopedVariables(depthBeforeScope) {
        const dropCount = this.stack.length - depthBeforeScope;
        for (let i = 0; i < dropCount; i += 1) {
            this.emit(Op.OP_DROP);
            this.popFromStack();
        }
    }
    visitCast(node) {
        node.expression = this.visit(node.expression);
        // Special case for sized bytes cast, since it has another node to traverse
        if (node.size) {
            node.size = this.visit(node.size);
            this.emit(Op.OP_NUM2BIN);
            this.popFromStack();
        }
        this.emit(compileCast(node.expression.type, node.type));
        this.popFromStack();
        this.pushToStack('(value)');
        return node;
    }
    visitFunctionCall(node) {
        if (node.identifier.name === GlobalFunction.CHECKMULTISIG) {
            return this.visitMultiSig(node);
        }
        if (GroupGlobalFunctions.includes(node.identifier.name)) {
            return this.visitTxStateFunction(node);
        }
        node.parameters = this.visitList(node.parameters);
        this.emit(compileGlobalFunction(node.identifier.name));
        this.popFromStack(node.parameters.length);
        this.pushToStack('(value)');
        return node;
    }
    visitMultiSig(node) {
        this.emit(encodeBool(false));
        this.pushToStack('(value)');
        node.parameters = this.visitList(node.parameters);
        this.emit(Op.OP_CHECKMULTISIG);
        const sigs = node.parameters[0];
        const pks = node.parameters[1];
        this.popFromStack(sigs.elements.length + pks.elements.length + 3);
        this.pushToStack('(value)');
        return node;
    }
    visitTxStateFunction(node) {
        // special handling of 2 bytes long indices
        if (GroupNthFunctions.includes(node.identifier.name)) {
            this.emit(encodeInt(BigInt(PushTxStateSpecifierMap[node.identifier.name])));
            this.pushToStack('(value)');
            node.parameters[0] = this.visit(node.parameters[0]);
            this.emit(Op.OP_2); // push size of binary data
            this.emit(Op.OP_NUM2BIN);
            this.emit(Op.OP_CAT);
            this.popFromStack();
            this.visit(node.parameters[1]);
            this.emit(Op.OP_CAT);
            this.popFromStack();
            this.emit(Op.OP_PUSH_TX_STATE);
            this.popFromStack();
            this.pushToStack('(value)');
            return node;
        }
        // general case for handling any parameters
        this.emit(encodeInt(BigInt(PushTxStateSpecifierMap[node.identifier.name])));
        this.pushToStack('(value)');
        node.parameters.forEach((parameter) => {
            this.visit(parameter);
            this.emit(Op.OP_CAT);
        });
        this.emit(Op.OP_PUSH_TX_STATE);
        this.popFromStack(node.parameters.length + 1);
        this.pushToStack('(value)');
        return node;
    }
    visitInstantiation(node) {
        if (node.identifier.name === Class.LOCKING_BYTECODE_P2PKT) {
            // OP_FALSE OP_TRUE OP_PUSH<20>
            this.emit(hexToBin('005114'));
            this.pushToStack('(value)');
            // <pkh>
            this.visit(node.parameters[0]);
            this.emit(Op.OP_CAT);
            this.popFromStack(2);
        }
        else if (node.identifier.name === Class.LOCKING_BYTECODE_P2ST) {
            // the emitting code is intentionally not optimized for reuse, etc.
            // OP_FALSE OP_PUSH<20>
            this.emit(hexToBin('0014'));
            this.pushToStack('(value)');
            // <template hash>
            this.visit(node.parameters[0]);
            this.emit(Op.OP_CAT);
            this.popFromStack();
            // commitment hash, either 0x to indicate empty commitment, or 20 bytes long hash
            if (node.parameters[1] instanceof HexLiteralNode) {
                if (node.parameters[1].value.byteLength === 0) {
                    // hex literal 0x
                    this.emit(hexToBin('00'));
                    this.emit(Op.OP_CAT);
                    this.popFromStack();
                }
                else {
                    // enforce 20 byte hash length at compilation time
                    if (node.parameters[1].value.byteLength !== 20) {
                        throw new InvalidParameterTypeError(node, [
                            node.parameters[1].type
                        ], [new BytesType(0), new BytesType(20),
                        ]);
                    }
                    // hex literal - 20 bytes long hash
                    // OP_PUSH<20>
                    this.emit(hexToBin('14'));
                    this.emit(Op.OP_CAT);
                    // <constraints hash> parameter
                    this.visit(node.parameters[1]);
                    this.emit(Op.OP_CAT);
                    this.popFromStack();
                }
            }
            else {
                // If the argument is not a literal, the script needs to check size
                this.visit(node.parameters[1]);
                this.emit(Op.OP_SIZE);
                this.emit(Op.OP_IF);
                // explicitly use 20 bytes here, this will also serve as a guard against ill-sized hashes
                this.emit(hexToBin('14'));
                this.pushToStack('(value)');
                this.emit(Op.OP_SWAP);
                this.emit(Op.OP_CAT);
                this.emit(Op.OP_ELSE);
                // otherwise use empty constraint
                this.emit(Op.OP_DROP);
                this.popFromStack();
                this.emit(hexToBin('00'));
                this.emit(Op.OP_ENDIF);
                this.emit(Op.OP_CAT);
                this.popFromStack();
            }
            // visible arguments, either 0x to indicate absence of visible arguments
            // or minimally encoded push only script
            if (node.parameters[2] instanceof HexLiteralNode && node.parameters[2].value.byteLength > 0) {
                // hex literal of encoded parameters, simply concatenate with top stack item
                this.visit(node.parameters[2]);
                this.emit(Op.OP_CAT);
                this.popFromStack();
            }
            else {
                // If the argument is not a literal, the script needs to check size
                this.visit(node.parameters[2]);
                this.emit(Op.OP_SIZE);
                this.emit(Op.OP_IF);
                this.emit(Op.OP_CAT);
                this.emit(Op.OP_ELSE);
                this.emit(Op.OP_DROP);
                this.emit(Op.OP_ENDIF);
                this.popFromStack();
            }
            this.popFromStack();
        }
        else if (node.identifier.name === Class.LOCKING_BYTECODE_NULLDATA) {
            // Total script = OP_RETURN (<VarInt> <chunk>)+
            // OP_RETURN
            this.emit(hexToBin('6a'));
            this.pushToStack('(value)');
            const { elements } = node.parameters[0];
            // <VarInt data chunk size (dynamic)>
            elements.forEach((el) => {
                this.visit(el);
                // Push the element's size (and calculate VarInt)
                this.emit(Op.OP_SIZE);
                if (el instanceof HexLiteralNode) {
                    // If the argument is a literal, we know its size
                    if (el.value.byteLength > 75) {
                        this.emit(hexToBin('4c'));
                        this.emit(Op.OP_SWAP);
                        this.emit(Op.OP_CAT);
                    }
                }
                else {
                    // If the argument is not a literal, the script needs to check size
                    this.emit(Op.OP_DUP);
                    this.emit(encodeInt(75n));
                    this.emit(Op.OP_GREATERTHAN);
                    this.emit(Op.OP_IF);
                    this.emit(hexToBin('4c'));
                    this.emit(Op.OP_SWAP);
                    this.emit(Op.OP_CAT);
                    this.emit(Op.OP_ENDIF);
                }
                // Concat size and arguments
                this.emit(Op.OP_SWAP);
                this.emit(Op.OP_CAT);
                this.emit(Op.OP_CAT);
                this.popFromStack();
            });
            this.popFromStack();
        }
        else {
            throw new Error(); // Should not happen
        }
        this.pushToStack('(value)');
        return node;
    }
    visitTupleIndexOp(node) {
        node.tuple = this.visit(node.tuple);
        if (node.index === 0) {
            this.emit(Op.OP_DROP);
            this.popFromStack();
        }
        else if (node.index === 1) {
            this.emit(Op.OP_NIP);
            this.nipFromStack();
        }
        return node;
    }
    visitBinaryOp(node) {
        node.left = this.visit(node.left);
        node.right = this.visit(node.right);
        const isNumeric = resultingType(node.left.type, node.right.type) === PrimitiveType.INT;
        this.emit(compileBinaryOp(node.operator, isNumeric));
        this.popFromStack(2);
        this.pushToStack('(value)');
        if (node.operator === BinaryOperator.SPLIT)
            this.pushToStack('(value)');
        return node;
    }
    visitUnaryOp(node) {
        node.expression = this.visit(node.expression);
        this.emit(compileUnaryOp(node.operator));
        this.popFromStack();
        this.pushToStack('(value)');
        return node;
    }
    visitNullaryOp(node) {
        this.emit(compileNullaryOp(node.operator));
        this.pushToStack('(value)');
        return node;
    }
    visitArray(node) {
        node.elements = this.visitList(node.elements);
        this.emit(encodeInt(BigInt(node.elements.length)));
        this.pushToStack('(value)');
        return node;
    }
    visitIdentifier(node) {
        const stackIndex = this.getStackIndex(node.name);
        this.emit(encodeInt(BigInt(stackIndex)));
        // If the final use is inside an if-statement, we still OP_PICK it
        // We do this so that there's no difference in stack depths between execution paths
        if (this.isOpRoll(node)) {
            this.emit(Op.OP_ROLL);
            this.removeFromStack(stackIndex);
        }
        else {
            this.emit(Op.OP_PICK);
        }
        this.pushToStack('(value)');
        return node;
    }
    isOpRoll(node) {
        return this.currentFunction.opRolls.get(node.name) === node && this.scopeDepth === 0;
    }
    visitBoolLiteral(node) {
        this.emit(encodeBool(node.value));
        this.pushToStack('(value)');
        return node;
    }
    visitIntLiteral(node) {
        this.emit(encodeInt(node.value));
        this.pushToStack('(value)');
        return node;
    }
    visitStringLiteral(node) {
        this.emit(encodeString(node.value));
        this.pushToStack('(value)');
        return node;
    }
    visitHexLiteral(node) {
        this.emit(node.value);
        this.pushToStack('(value)');
        return node;
    }
    visitMerkleMacro(node) {
        if (node.treeHeight <= 0n) {
            throw new Error('Merkle tree height must be at least 1');
        }
        this.visit(node.proof);
        this.emit(Op.OP_0);
        this.emit(encodeInt(node.treeHeight));
        this.emit(Op.OP_EXEC);
        this.popFromStack(1);
        for (let i = 0n; i < node.treeHeight; i += 1n) {
            this.pushToStack('(value)');
        }
        this.visit(node.leafIndex);
        this.emit(hexToBin('766b5297647c687ea9c17c6c52967c')); // loop code
        this.pushToStack('(value)');
        this.emit(Op.OP_SWAP);
        this.emit(Op.OP_ROT);
        this.visit(node.leafHash);
        this.emit(Op.OP_SWAP);
        this.emit(Op.OP_3);
        this.emit(Op.OP_3);
        this.emit(Op.OP_EXEC);
        this.popFromStack();
        for (let i = 1n; i < node.treeHeight; i += 1n) {
            this.emit(Op.OP_3);
            this.emit(Op.OP_ROLL);
            this.emit(Op.OP_3);
            this.emit(Op.OP_3);
            this.emit(Op.OP_EXEC);
            this.popFromStack();
        }
        this.emit(Op.OP_NIP);
        this.emit(Op.OP_NIP);
        this.popFromStack(2);
        return node;
    }
}
//# sourceMappingURL=GenerateTargetTraversal.js.map