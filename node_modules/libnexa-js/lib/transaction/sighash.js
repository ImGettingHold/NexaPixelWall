'use strict';

var buffer = require('buffer');

var Signature = require('../crypto/signature');
var Script = require('../script');
var Output = require('./output');
var BufferReader = require('../encoding/bufferreader');
var BufferWriter = require('../encoding/bufferwriter');
var BN = require('../crypto/bn');
var Hash = require('../crypto/hash');
var ECDSA = require('../crypto/ecdsa');
var Schnorr = require('../crypto/schnorr');
var $ = require('../util/preconditions');
var BufferUtil = require('../util/buffer');
var Interpreter = require('../script/interpreter');
var _ = require('lodash');
const Opcode = require('../opcode');

var SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';
var BITS_64_ON = 'ffffffffffffffff';

// By default, we sign with sighash_forkid
var DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;


var sighashForNexa = function(transaction, sighashType, inputNumber, subscript) {
  var input = transaction.inputs[inputNumber];

  function GetPrevoutHash(tx) {
    var writer = new BufferWriter()

    _.each(tx.inputs, function(input) {
        writer.writeUInt8(input.type);
        writer.writeReverse(input.prevTxId);
    });

    var buf = writer.toBuffer();
    var ret = Hash.sha256sha256(buf);
    return ret;
  }

  function GetSequenceHash(tx) {
    var writer = new BufferWriter()

    _.each(tx.inputs, function(input) {
      writer.writeUInt32LE(input.sequenceNumber);
    });

    var buf = writer.toBuffer();
    var ret = Hash.sha256sha256(buf);
    return ret;
  }

  function GetInputAmountHash(tx) {
    var writer = new BufferWriter()

    _.each(tx.inputs, function(input) {
      writer.writeUInt64LEBN(input.amountBN);
    });

    var buf = writer.toBuffer();
    var ret = Hash.sha256sha256(buf);
    return ret;
  }

  function GetOutputsHash(tx, n) {
    var writer = new BufferWriter()

    if ( _.isUndefined(n)) {
      _.each(tx.outputs, function(output) {
        output.toBufferWriter(writer);
      });
    } else {
      tx.outputs[n].toBufferWriter(writer);
    }
   
    var buf = writer.toBuffer();
    var ret = Hash.sha256sha256(buf);
    return ret;
  }

  var hashPrevouts = BufferUtil.emptyBuffer(32);
  var hashInputAmount = BufferUtil.emptyBuffer(32);
  var hashSequence = BufferUtil.emptyBuffer(32);
  var hashOutputs = BufferUtil.emptyBuffer(32);

  // if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
  //   hashPrevouts = GetPrevoutHash(transaction);
  // }

  // if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&
  //   (sighashType & 31) != Signature.SIGHASH_SINGLE &&
  //   (sighashType & 31) != Signature.SIGHASH_NONE) {
  //   hashSequence = GetSequenceHash(transaction);
  // }

  // if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {
  //   hashOutputs = GetOutputsHash(transaction);
  // } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
  //   hashOutputs = GetOutputsHash(transaction, inputNumber);
  // }

  // TODO: classify by sighashtype
  hashPrevouts = GetPrevoutHash(transaction);
  hashSequence = GetSequenceHash(transaction);
  hashInputAmount = GetInputAmountHash(transaction);
  hashOutputs = GetOutputsHash(transaction);

  var writer = new BufferWriter()

  // Version
  writer.writeUInt8(transaction.version);

  // Input prevouts/nSequence (none/all, depending on flags)
  writer.write(hashPrevouts);
  writer.write(hashInputAmount);
  writer.write(hashSequence);

  // scriptCode of the input (serialized as scripts inside CTxOuts)
  writer.writeVarintNum(subscript.toBuffer().length)
  writer.write(subscript.toBuffer());

  // Outputs (none/one/all, depending on flags)
  writer.write(hashOutputs);

  // Locktime
  writer.writeUInt32LE(transaction.nLockTime);

  // sighashType 
  writer.writeUInt8(sighashType);
  
  var buf = writer.toBuffer();
  var ret = Hash.sha256sha256(buf);
  ret = new BufferReader(ret).readReverse();
  return ret;
}

/**
 * Returns a buffer of length 32 bytes with the hash that needs to be signed
 * for OP_CHECKSIG.
 *
 * @name Signing.sighash
 * @param {Transaction} transaction the transaction to sign
 * @param {number} sighashType the type of the hash
 * @param {number} inputNumber the input index for the signature
 * @param {Script} subscript the script that will be signed
 * @param {satoshisBN} input's amount (for  ForkId signatures)
 *
 */
var sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {
  var Transaction = require('./transaction');
  var Input = require('./input');
  
  if (_.isUndefined(flags)){
    flags = DEFAULT_SIGN_FLAGS;
  }

  // Copy transaction
  var txcopy = Transaction.shallowCopy(transaction);

  // Copy script
  subscript = new Script(subscript);

  // ** IMPORTANT: Currently this lib support ONLY 'SIGHASH_NEXA_ALL', using other values is on your own risk!!! **
  if (sighashType === Signature.SIGHASH_NEXA_ALL) {
    return sighashForNexa(txcopy, sighashType, inputNumber, subscript);
  }

  // For no ForkId sighash, separators need to be removed.
  subscript.removeCodeseparators();

  var i;

  for (i = 0; i < txcopy.inputs.length; i++) {
    // Blank signatures for other inputs
    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
  }

  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);

  if ((sighashType & 31) === Signature.SIGHASH_NONE ||
    (sighashType & 31) === Signature.SIGHASH_SINGLE) {

    // clear all sequenceNumbers
    for (i = 0; i < txcopy.inputs.length; i++) {
      if (i !== inputNumber) {
        txcopy.inputs[i].sequenceNumber = 0;
      }
    }
  }

  if ((sighashType & 31) === Signature.SIGHASH_NONE) {
    txcopy.outputs = [];

  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
    // The SIGHASH_SINGLE bug.
    // https://bitcointalk.org/index.php?topic=260595.0
    if (inputNumber >= txcopy.outputs.length) {
      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');
    }

    txcopy.outputs.length = inputNumber + 1;

    for (i = 0; i < inputNumber; i++) {
      txcopy.outputs[i] = new Output({
        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),
        script: Script.empty()
      });
    }
  }
  
  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
    txcopy.inputs = [txcopy.inputs[inputNumber]];
  }

  var buf = new BufferWriter()
    .write(txcopy.toBuffer())
    .writeInt32LE(sighashType)
    .toBuffer();
  var ret = Hash.sha256sha256(buf);
  ret = new BufferReader(ret).readReverse();
  return ret;
};

/**
 * Create a signature
 *
 * @name Signing.sign
 * @param {Transaction} transaction
 * @param {PrivateKey} privateKey
 * @param {number} sighash
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {satoshisBN} input's amount
 * @param {signingMethod} signingMethod "ecdsa" or "schnorr" to sign a tx
 * @return {Signature}
 */
function sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags, signingMethod) {
  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);

  signingMethod = signingMethod || "schnorr";
  let sig;

  if (signingMethod === "schnorr") {
    sig = Schnorr.sign(hashbuf, privateKey, 'little');
    return sig;
  } else if (signingMethod === "ecdsa") {
    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({
      nhashtype: sighashType
    });
    return sig;
  }
}

/**
 * Verify a signature
 *
 * @name Signing.verify
 * @param {Transaction} transaction
 * @param {Signature} signature
 * @param {PublicKey} publicKey
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {satoshisBN} input's amount
 * @param {flags} verification flags
 * @param {signingMethod} signingMethod 'ecdsa' or 'schnorr' to sign a tx
 * @return {boolean}
 */
function verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags, signingMethod) {
  $.checkArgument(!_.isUndefined(transaction));
  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);
  
  signingMethod = signingMethod || 'schnorr';

  if (signingMethod === 'schnorr') {
    return Schnorr.verify(hashbuf, signature, publicKey, 'little')
  } else if(signingMethod === 'ecdsa') {
    return ECDSA.verify(hashbuf, signature, publicKey, 'little');
  }
}

/**
 * @namespace Signing
 */
module.exports = {
  sighash: sighash,
  sign: sign,
  verify: verify
};
