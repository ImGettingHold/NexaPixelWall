declare const _exports: {
    (serialized?: any): import("./transaction");
    new (serialized?: any): import("./transaction");
    DUST_AMOUNT: number;
    FEE_SECURITY_MARGIN: number;
    MAX_MONEY: number;
    NLOCKTIME_BLOCKHEIGHT_LIMIT: number;
    NLOCKTIME_MAX_VALUE: number;
    FEE_PER_KB: number;
    CHANGE_OUTPUT_MAX_SIZE: number;
    shallowCopy(transaction: import("./transaction")): import("./transaction");
    Input: {
        (params: any): import("./input/input");
        new (params: any): import("./input/input");
        MAXINT: number;
        DEFAULT_SEQNUMBER: number;
        DEFAULT_LOCKTIME_SEQNUMBER: number;
        DEFAULT_RBF_SEQNUMBER: number;
        SEQUENCE_LOCKTIME_TYPE_FLAG: number;
        DEFAULT_TYPE: number;
        fromObject(obj: any): import("./input/input");
        fromBufferReader(br: any): import("./input/input");
        PublicKey: typeof import("./input/publickey");
        PublicKeyHash: typeof import("./input/publickeyhash");
        PublicKeyTemplate: typeof import("./input/publickeytemplate");
        MultiSig: typeof import("./input/multisig");
        MultiSigScriptHash: typeof import("./input/multisigscripthash");
        Escrow: typeof import("./input/escrow");
        ScriptTemplate: typeof import("./input/scripttemplate");
    };
    Output: typeof import("./output");
    UnspentOutput: typeof import("./unspentoutput");
    Signature: typeof import("./signature");
    Sighash: {
        sighash: (transaction: import("./transaction"), sighashType: number, inputNumber: number, subscript: {
            (from?: any): import("../script/script");
            new (from?: any): import("../script/script");
            fromBuffer(buffer: any): import("../script/script");
            fromASM(str: any): import("../script/script");
            fromHex(str: any): import("../script/script");
            fromString(str: any): import("../script/script");
            types: typeof import("../script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("../script/script").outputIdentifiers;
            inputIdentifiers: typeof import("../script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
            buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
            buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
            buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildPublicKeyOut(pubkey: any): import("../script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
            buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
            buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
            buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
            empty(): import("../script/script");
            fromAddress(address: any): import("../script/script");
            Interpreter: typeof import("../script/interpreter");
        }, satoshisBN: any, flags: any) => Buffer;
        sign: (transaction: Transaction, privateKey: PrivateKey, sighashType: any, inputIndex: number, subscript: {
            (from?: any): import("../script/script");
            new (from?: any): import("../script/script");
            fromBuffer(buffer: any): import("../script/script");
            fromASM(str: any): import("../script/script");
            fromHex(str: any): import("../script/script");
            fromString(str: any): import("../script/script");
            types: typeof import("../script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("../script/script").outputIdentifiers;
            inputIdentifiers: typeof import("../script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
            buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
            buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
            buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildPublicKeyOut(pubkey: any): import("../script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
            buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
            buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
            buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
            empty(): import("../script/script");
            fromAddress(address: any): import("../script/script");
            Interpreter: typeof import("../script/interpreter");
        }, satoshisBN: any, flags: any, signingMethod: any) => import("../crypto/signature");
        verify: (transaction: Transaction, signature: import("../crypto/signature"), publicKey: PublicKey, inputIndex: number, subscript: {
            (from?: any): import("../script/script");
            new (from?: any): import("../script/script");
            fromBuffer(buffer: any): import("../script/script");
            fromASM(str: any): import("../script/script");
            fromHex(str: any): import("../script/script");
            fromString(str: any): import("../script/script");
            types: typeof import("../script/script").types;
            OP_RETURN_STANDARD_SIZE: number;
            outputIdentifiers: typeof import("../script/script").outputIdentifiers;
            inputIdentifiers: typeof import("../script/script").inputIdentifiers;
            buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
            buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
            buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
            buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
            buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
            buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
            buildPublicKeyOut(pubkey: any): import("../script/script");
            buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
            buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
            buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
            buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
            buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
            empty(): import("../script/script");
            fromAddress(address: any): import("../script/script");
            Interpreter: typeof import("../script/interpreter");
        }, satoshisBN: any, flags: any, signingMethod: any) => boolean;
    };
};
export = _exports;
export const Input: {
    (params: any): import("./input/input");
    new (params: any): import("./input/input");
    MAXINT: number;
    DEFAULT_SEQNUMBER: number;
    DEFAULT_LOCKTIME_SEQNUMBER: number;
    DEFAULT_RBF_SEQNUMBER: number;
    SEQUENCE_LOCKTIME_TYPE_FLAG: number;
    DEFAULT_TYPE: number;
    fromObject(obj: any): import("./input/input");
    fromBufferReader(br: any): import("./input/input");
    PublicKey: typeof import("./input/publickey");
    PublicKeyHash: typeof import("./input/publickeyhash");
    PublicKeyTemplate: typeof import("./input/publickeytemplate");
    MultiSig: typeof import("./input/multisig");
    MultiSigScriptHash: typeof import("./input/multisigscripthash");
    Escrow: typeof import("./input/escrow");
    ScriptTemplate: typeof import("./input/scripttemplate");
};
export const Output: typeof import("./output");
export const UnspentOutput: typeof import("./unspentoutput");
export const Signature: typeof import("./signature");
export const Sighash: {
    sighash: (transaction: import("./transaction"), sighashType: number, inputNumber: number, subscript: {
        (from?: any): import("../script/script");
        new (from?: any): import("../script/script");
        fromBuffer(buffer: any): import("../script/script");
        fromASM(str: any): import("../script/script");
        fromHex(str: any): import("../script/script");
        fromString(str: any): import("../script/script");
        types: typeof import("../script/script").types;
        OP_RETURN_STANDARD_SIZE: number;
        outputIdentifiers: typeof import("../script/script").outputIdentifiers;
        inputIdentifiers: typeof import("../script/script").inputIdentifiers;
        buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
        buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
        buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
        buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
        buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildPublicKeyOut(pubkey: any): import("../script/script");
        buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
        buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
        buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
        buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
        empty(): import("../script/script");
        fromAddress(address: any): import("../script/script");
        Interpreter: typeof import("../script/interpreter");
    }, satoshisBN: any, flags: any) => Buffer;
    sign: (transaction: Transaction, privateKey: PrivateKey, sighashType: any, inputIndex: number, subscript: {
        (from?: any): import("../script/script");
        new (from?: any): import("../script/script");
        fromBuffer(buffer: any): import("../script/script");
        fromASM(str: any): import("../script/script");
        fromHex(str: any): import("../script/script");
        fromString(str: any): import("../script/script");
        types: typeof import("../script/script").types;
        OP_RETURN_STANDARD_SIZE: number;
        outputIdentifiers: typeof import("../script/script").outputIdentifiers;
        inputIdentifiers: typeof import("../script/script").inputIdentifiers;
        buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
        buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
        buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
        buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
        buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildPublicKeyOut(pubkey: any): import("../script/script");
        buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
        buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
        buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
        buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
        empty(): import("../script/script");
        fromAddress(address: any): import("../script/script");
        Interpreter: typeof import("../script/interpreter");
    }, satoshisBN: any, flags: any, signingMethod: any) => import("../crypto/signature");
    verify: (transaction: Transaction, signature: import("../crypto/signature"), publicKey: PublicKey, inputIndex: number, subscript: {
        (from?: any): import("../script/script");
        new (from?: any): import("../script/script");
        fromBuffer(buffer: any): import("../script/script");
        fromASM(str: any): import("../script/script");
        fromHex(str: any): import("../script/script");
        fromString(str: any): import("../script/script");
        types: typeof import("../script/script").types;
        OP_RETURN_STANDARD_SIZE: number;
        outputIdentifiers: typeof import("../script/script").outputIdentifiers;
        inputIdentifiers: typeof import("../script/script").inputIdentifiers;
        buildEscrowOut(inputPublicKeys: import("../publickey")[], reclaimPublicKey: import("../publickey")): import("../script/script");
        buildMultisigOut(publicKeys: import("../publickey")[], threshold: number, opts?: any): import("../script/script");
        buildMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildP2SHMultisigIn(pubkeys: import("../publickey")[], threshold: number, signatures: any[], opts?: any): import("../script/script");
        buildPublicKeyHashOut(to: import("../publickey") | import("../address")): import("../script/script");
        buildScriptTemplateOut(to: string | import("../publickey") | import("../address")): import("../script/script");
        buildGroupedPublicKeyTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildGroupedScriptTemplateOut(to: string | import("../publickey") | import("../address"), groupId: string | Buffer | import("../address"), groupAmount: bigint | Buffer): import("../script/script");
        buildPublicKeyOut(pubkey: any): import("../script/script");
        buildDataOut(data: string | Buffer, encoding: string): import("../script/script");
        buildScriptHashOut(script: import("../address") | import("../script/script")): import("../script/script");
        buildPublicKeyIn(signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyHashIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildPublicKeyTemplateIn(publicKey: string | Buffer | import("../publickey"), signature: Buffer | import("../crypto/signature"), sigtype?: number): import("../script/script");
        buildScriptTemplateIn(template: import("../script/script"), constraint: import("../opcode") | import("../script/script"), satisfier: Buffer | import("../script/script"), sigtype?: number): import("../script/script");
        buildEscrowIn(publicKey: import("../publickey"), signature: import("../crypto/signature"), redeemScript: import("../script/script")): import("../script/script");
        empty(): import("../script/script");
        fromAddress(address: any): import("../script/script");
        Interpreter: typeof import("../script/interpreter");
    }, satoshisBN: any, flags: any, signingMethod: any) => boolean;
};
//# sourceMappingURL=index.d.ts.map