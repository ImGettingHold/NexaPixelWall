export = Opcode;
declare function Opcode(num: any): Opcode;
declare class Opcode {
    constructor(num: any);
    toHex(): any;
    toBuffer(): Buffer;
    toNumber(): any;
    toString(): any;
    /**
     * Will return a string formatted for the console
     *
     * @returns {string} Script opcode
     */
    inspect(): string;
}
declare namespace Opcode {
    function fromBuffer(buf: any): Opcode;
    function fromNumber(num: any): Opcode;
    function fromString(str: any): Opcode;
    function smallInt(n: any): Opcode;
    namespace map {
        let OP_FALSE: number;
        let OP_0: number;
        let OP_PUSHDATA1: number;
        let OP_PUSHDATA2: number;
        let OP_PUSHDATA4: number;
        let OP_1NEGATE: number;
        let OP_RESERVED: number;
        let OP_TRUE: number;
        let OP_1: number;
        let OP_2: number;
        let OP_3: number;
        let OP_4: number;
        let OP_5: number;
        let OP_6: number;
        let OP_7: number;
        let OP_8: number;
        let OP_9: number;
        let OP_10: number;
        let OP_11: number;
        let OP_12: number;
        let OP_13: number;
        let OP_14: number;
        let OP_15: number;
        let OP_16: number;
        let OP_NOP: number;
        let OP_VER: number;
        let OP_IF: number;
        let OP_NOTIF: number;
        let OP_VERIF: number;
        let OP_VERNOTIF: number;
        let OP_ELSE: number;
        let OP_ENDIF: number;
        let OP_VERIFY: number;
        let OP_RETURN: number;
        let OP_TOALTSTACK: number;
        let OP_FROMALTSTACK: number;
        let OP_2DROP: number;
        let OP_2DUP: number;
        let OP_3DUP: number;
        let OP_2OVER: number;
        let OP_2ROT: number;
        let OP_2SWAP: number;
        let OP_IFDUP: number;
        let OP_DEPTH: number;
        let OP_DROP: number;
        let OP_DUP: number;
        let OP_NIP: number;
        let OP_OVER: number;
        let OP_PICK: number;
        let OP_ROLL: number;
        let OP_ROT: number;
        let OP_SWAP: number;
        let OP_TUCK: number;
        let OP_CAT: number;
        let OP_SPLIT: number;
        let OP_NUM2BIN: number;
        let OP_BIN2NUM: number;
        let OP_SIZE: number;
        let OP_INVERT: number;
        let OP_AND: number;
        let OP_OR: number;
        let OP_XOR: number;
        let OP_EQUAL: number;
        let OP_EQUALVERIFY: number;
        let OP_RESERVED1: number;
        let OP_RESERVED2: number;
        let OP_1ADD: number;
        let OP_1SUB: number;
        let OP_2MUL: number;
        let OP_2DIV: number;
        let OP_NEGATE: number;
        let OP_ABS: number;
        let OP_NOT: number;
        let OP_0NOTEQUAL: number;
        let OP_ADD: number;
        let OP_SUB: number;
        let OP_MUL: number;
        let OP_DIV: number;
        let OP_MOD: number;
        let OP_LSHIFT: number;
        let OP_RSHIFT: number;
        let OP_BOOLAND: number;
        let OP_BOOLOR: number;
        let OP_NUMEQUAL: number;
        let OP_NUMEQUALVERIFY: number;
        let OP_NUMNOTEQUAL: number;
        let OP_LESSTHAN: number;
        let OP_GREATERTHAN: number;
        let OP_LESSTHANOREQUAL: number;
        let OP_GREATERTHANOREQUAL: number;
        let OP_MIN: number;
        let OP_MAX: number;
        let OP_WITHIN: number;
        let OP_RIPEMD160: number;
        let OP_SHA1: number;
        let OP_SHA256: number;
        let OP_HASH160: number;
        let OP_HASH256: number;
        let OP_CODESEPARATOR: number;
        let OP_CHECKSIG: number;
        let OP_CHECKSIGVERIFY: number;
        let OP_CHECKMULTISIG: number;
        let OP_CHECKMULTISIGVERIFY: number;
        let OP_NOP2: number;
        let OP_CHECKLOCKTIMEVERIFY: number;
        let OP_NOP3: number;
        let OP_CHECKSEQUENCEVERIFY: number;
        let OP_NOP1: number;
        let OP_NOP4: number;
        let OP_NOP5: number;
        let OP_NOP6: number;
        let OP_NOP7: number;
        let OP_NOP8: number;
        let OP_NOP9: number;
        let OP_NOP10: number;
        let OP_CHECKDATASIG: number;
        let OP_CHECKDATASIGVERIFY: number;
        let OP_REVERSEBYTES: number;
        let OP_PREFIX_BEGIN: number;
        let OP_PREFIX_END: number;
        let OP_SMALLINTEGER: number;
        let OP_PUBKEYS: number;
        let OP_PUBKEYHASH: number;
        let OP_PUBKEY: number;
        let OP_INVALIDOPCODE: number;
        let OP_INPUTINDEX: number;
        let OP_ACTIVEBYTECODE: number;
        let OP_TXVERSION: number;
        let OP_TXINPUTCOUNT: number;
        let OP_TXOUTPUTCOUNT: number;
        let OP_TXLOCKTIME: number;
        let OP_UTXOVALUE: number;
        let OP_UTXOBYTECODE: number;
        let OP_OUTPOINTTXHASH: number;
        let OP_OUTPOINTINDEX: number;
        let OP_INPUTBYTECODE: number;
        let OP_INPUTSEQUENCENUMBER: number;
        let OP_OUTPUTVALUE: number;
        let OP_OUTPUTBYTECODE: number;
        let OP_RESERVED3: number;
        let OP_RESERVED4: number;
    }
    let reverseMap: any[];
    /**
     * @returns true if opcode is one of OP_0, OP_1, ..., OP_16
     */
    function isSmallIntOp(opcode: any): boolean;
}
//# sourceMappingURL=opcode.d.ts.map